---
description: 
globs: 
alwaysApply: true
---
# Regla: versioning.mdc

## üéØ Prop√≥sito
Establecer un sistema coherente para el versionado de c√≥digo, APIs y recursos, siguiendo est√°ndares como SemVer, permitiendo actualizaciones predecibles y minimizando el impacto en usuarios existentes.

---

## üì¶ Versionado de c√≥digo

### 1. Semantic Versioning (SemVer)

Estructura: `MAJOR.MINOR.PATCH` (ej. `1.2.3`)

- **MAJOR**: Cambios incompatibles con versiones anteriores
- **MINOR**: Funcionalidades nuevas compatibles con versiones anteriores
- **PATCH**: Correcciones de errores compatibles con versiones anteriores

```json
// package.json
{
  "name": "my-app",
  "version": "1.2.3",
  "private": true,
  "scripts": {
    "release:patch": "npm version patch && git push && git push --tags",
    "release:minor": "npm version minor && git push && git push --tags",
    "release:major": "npm version major && git push && git push --tags"
  }
}
```

### 2. Convencional Commits

Formato de mensajes de commit estructurados para generar changelogs autom√°ticamente:

```bash
<tipo>[√°mbito opcional]: <descripci√≥n>

[cuerpo opcional]

[nota(s) al pie opcional(es)]
```

Tipos principales:
- `fix:` - Correcci√≥n de errores (PATCH)
- `feat:` - Nueva funcionalidad (MINOR)
- `feat!:` o `fix!:` - Cambio incompatible (MAJOR)
- `docs:` - Cambios en documentaci√≥n
- `style:` - Cambios de formato
- `refactor:` - Refactorizaci√≥n de c√≥digo
- `test:` - Adici√≥n o correcci√≥n de tests
- `chore:` - Tareas de mantenimiento

```typescript
// .commitlintrc.js
module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'body-max-line-length': [2, 'always', 100],
    'subject-case': [
      2,
      'never',
      ['pascal-case', 'upper-case']
    ]
  }
};
```

---

## üåê Versionado de APIs

### 1. Versionado por URL

```typescript
// Ejemplo de estructura de API con versi√≥n en URL
// app/api/v1/users/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
  // Implementaci√≥n de v1
  return NextResponse.json({ users: [/* ... */] });
}

// app/api/v2/users/route.ts
export async function GET(request: NextRequest) {
  // Implementaci√≥n de v2 con mejoras/cambios
  return NextResponse.json({ 
    data: { users: [/* ... */] }, 
    pagination: { /* ... */ } 
  });
}
```

### 2. Versionado por encabezado o par√°metro

```typescript
// app/api/users/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
  // Opci√≥n 1: Versi√≥n por encabezado
  const apiVersion = request.headers.get('x-api-version') || '1';
  
  // Opci√≥n 2: Versi√≥n por par√°metro de consulta
  // const apiVersion = request.nextUrl.searchParams.get('version') || '1';
  
  if (apiVersion === '1') {
    // Implementaci√≥n v1
    return NextResponse.json({ users: [/* ... */] });
  } else if (apiVersion === '2') {
    // Implementaci√≥n v2
    return NextResponse.json({ 
      data: { users: [/* ... */] }, 
      pagination: { /* ... */ } 
    });
  } else {
    // Versi√≥n no soportada
    return NextResponse.json(
      { error: `API version ${apiVersion} not supported` },
      { status: 400 }
    );
  }
}
```

### 3. Gesti√≥n de cambios en API

```typescript
// lib/api/users/controllers.ts
import { UserResponseV1, UserResponseV2, User } from '../types';

// Transformadores para diferentes versiones de la API
export function transformUserV1(user: User): UserResponseV1 {
  return {
    id: user.id,
    name: user.name,
    email: user.email,
  };
}

export function transformUserV2(user: User): UserResponseV2 {
  return {
    id: user.id,
    fullName: user.name,
    email: user.email,
    profileUrl: `/users/${user.id}`,
    createdAt: user.createdAt.toISOString(),
    // Campo nuevo en v2
    status: user.status || 'active',
  };
}

// Implementaci√≥n de controladores por versi√≥n
export async function getUsersV1() {
  const users = await fetchUsers();
  return users.map(transformUserV1);
}

export async function getUsersV2() {
  const users = await fetchUsers();
  return {
    data: users.map(transformUserV2),
    pagination: {
      total: users.length,
      page: 1,
      perPage: 10,
    }
  };
}
```

---

## üìù Documentaci√≥n de versiones

### 1. Changelogs autom√°ticos

```json
// package.json (configuraci√≥n standard-version)
{
  "scripts": {
    "release": "standard-version"
  },
  "standard-version": {
    "types": [
      {"type": "feat", "section": "Nuevas funcionalidades"},
      {"type": "fix", "section": "Correcciones de errores"},
      {"type": "docs", "section": "Documentaci√≥n"},
      {"type": "style", "hidden": true},
      {"type": "refactor", "section": "Refactorizaciones"},
      {"type": "perf", "section": "Mejoras de rendimiento"},
      {"type": "test", "hidden": true},
      {"type": "chore", "hidden": true}
    ]
  }
}
```

### 2. Documentaci√≥n de API para desarrolladores

```typescript
// lib/api/swagger.ts
import { createSwaggerSpec } from 'next-swagger-doc';

export const apiSpec = createSwaggerSpec({
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'Mi API',
      version: '1.0.0',
      description: 'Documentaci√≥n de la API',
    },
    servers: [{ url: '/api' }],
    paths: {
      '/users': {
        get: {
          summary: 'Obtener usuarios',
          parameters: [
            {
              name: 'x-api-version',
              in: 'header',
              schema: { type: 'string', enum: ['1', '2'] },
              required: false,
              description: 'Versi√≥n de la API a utilizar',
            },
          ],
          responses: {
            '200': {
              description: 'Lista de usuarios',
              content: {
                'application/json': {
                  schema: {
                    oneOf: [
                      { $ref: '#/components/schemas/UsersResponseV1' },
                      { $ref: '#/components/schemas/UsersResponseV2' },
                    ],
                  },
                },
              },
            },
          },
        },
      },
    },
    components: {
      schemas: {
        UsersResponseV1: {
          type: 'array',
          items: { $ref: '#/components/schemas/UserV1' },
        },
        UserV1: {
          type: 'object',
          properties: {
            id: { type: 'string' },
            name: { type: 'string' },
            email: { type: 'string' },
          },
        },
        UsersResponseV2: {
          type: 'object',
          properties: {
            data: {
              type: 'array',
              items: { $ref: '#/components/schemas/UserV2' },
            },
            pagination: { $ref: '#/components/schemas/Pagination' },
          },
        },
        UserV2: {
          type: 'object',
          properties: {
            id: { type: 'string' },
            fullName: { type: 'string' },
            email: { type: 'string' },
            profileUrl: { type: 'string' },
            createdAt: { type: 'string', format: 'date-time' },
            status: { type: 'string', enum: ['active', 'inactive'] },
          },
        },
        Pagination: {
          type: 'object',
          properties: {
            total: { type: 'integer' },
            page: { type: 'integer' },
            perPage: { type: 'integer' },
          },
        },
      },
    },
  },
});
```

---

## üõ†Ô∏è Reglas para Cursor (Versionado)

- Utilizar siempre SemVer para versionado de paquetes y aplicaciones
- Seguir el formato de Conventional Commits para todos los mensajes
- Incluir versi√≥n en la API (preferiblemente en URL) para cambios incompatibles
- Mantener al menos una versi√≥n anterior para compatibilidad
- Documentar cada cambio de versi√≥n en un CHANGELOG
- Comunicar deprecated endpoints/features con antelaci√≥n antes de eliminarlos
- Evitar cambios incompatibles en versiones menores y de parche
- Utilizar encabezados para versiones espec√≠ficas de clientes
- Implementar pruebas autom√°ticas para asegurar compatibilidad entre versiones
- Mantener definiciones claras de contratos de API por versi√≥n
- Considerar estrategias de blue-green deployment para actualizaciones
- Generar documentaci√≥n actualizada con cada versi√≥n nueva
- No reutilizar versiones eliminadas o deprecadas
- Incluir fechas de fin de soporte (EOL) para versiones antiguas
- Seguir un esquema de branches alineado con el flujo de versionado