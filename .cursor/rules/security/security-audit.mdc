---
description: 
globs: 
alwaysApply: false
---
# Regla: security-audit.mdc

## üéØ Prop√≥sito
Establecer un conjunto est√°ndar de pr√°cticas para auditor√≠as de seguridad peri√≥dicas y sistem√°ticas que permitan identificar, analizar y mitigar vulnerabilidades en aplicaciones web, asegurando la detecci√≥n temprana de problemas y el mantenimiento de altos niveles de seguridad.

---

## üîç Auditor√≠as Automatizadas

### 1. Configuraci√≥n de escaneo de dependencias

```yaml
# .github/workflows/dependency-scan.yml
name: Dependency Security Scan

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  schedule:
    - cron: '0 0 * * 1' # Ejecutar cada lunes a medianoche

jobs:
  dependency-scan:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run npm audit
        run: npm audit --production --audit-level=high
      
      - name: Run Snyk security scan
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high --all-projects
      
      - name: Generate dependency report
        run: npm list --all --json > dependency-report.json
        
      - name: Upload dependency report
        uses: actions/upload-artifact@v3
        with:
          name: dependency-report
          path: dependency-report.json
```

### 2. Escaneo de c√≥digo est√°tico (SAST)

```yaml
# .github/workflows/sast-scan.yml
name: Static Application Security Testing

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 0 * * 3' # Ejecutar cada mi√©rcoles a medianoche

jobs:
  sast-scan:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
          
      - name: Run ESLint security rules
        run: |
          npm ci
          npx eslint . --ext .js,.jsx,.ts,.tsx --config .eslintrc.security.js
          
      - name: Run SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          
      - name: Run Semgrep
        uses: returntocorp/semgrep-action@v1
        with:
          config: >-
            p/owasp-top-ten
            p/r2c-security-audit
            p/javascript
            p/react
            p/nextjs
            p/typescript
          generateSarif: true
      
      - name: Upload SARIF file
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: semgrep.sarif
```

### 3. Integraci√≥n con herramientas de seguridad

```typescript
// scripts/security/run-audit.ts
import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

interface AuditOptions {
  skipDependencyCheck?: boolean;
  skipStaticAnalysis?: boolean;
  outputDir?: string;
  severity?: 'low' | 'moderate' | 'high' | 'critical';
}

async function runSecurityAudit(options: AuditOptions = {}) {
  const {
    skipDependencyCheck = false,
    skipStaticAnalysis = false,
    outputDir = './security-reports',
    severity = 'high',
  } = options;
  
  // Crear directorio de salida si no existe
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  
  console.log('üîç Iniciando auditor√≠a de seguridad...');
  
  // Ejecutar npm audit
  if (!skipDependencyCheck) {
    console.log('üì¶ Analizando dependencias...');
    try {
      const npmAuditOutput = execSync(`npm audit --json --audit-level=${severity}`);
      fs.writeFileSync(
        path.join(outputDir, 'npm-audit-report.json'),
        npmAuditOutput
      );
      console.log('‚úÖ An√°lisis de dependencias completado');
    } catch (error) {
      const errorOutput = error.stdout.toString();
      fs.writeFileSync(
        path.join(outputDir, 'npm-audit-report.json'),
        errorOutput
      );
      console.error('‚ö†Ô∏è Se encontraron vulnerabilidades en dependencias');
    }
  }
  
  // Ejecutar an√°lisis est√°tico
  if (!skipStaticAnalysis) {
    console.log('üîé Ejecutando an√°lisis est√°tico de c√≥digo...');
    
    // ESLint con reglas de seguridad
    try {
      const eslintOutput = execSync(
        'npx eslint . --ext .js,.jsx,.ts,.tsx --config .eslintrc.security.js --format json',
        { stdio: 'pipe' }
      );
      fs.writeFileSync(
        path.join(outputDir, 'eslint-security-report.json'),
        eslintOutput
      );
      console.log('‚úÖ An√°lisis ESLint completado');
    } catch (error) {
      const errorOutput = error.stdout.toString();
      fs.writeFileSync(
        path.join(outputDir, 'eslint-security-report.json'),
        errorOutput
      );
      console.error('‚ö†Ô∏è ESLint encontr√≥ problemas de seguridad');
    }
    
    // Semgrep
    try {
      console.log('üîé Ejecutando Semgrep...');
      execSync(
        'npx semgrep --config=p/owasp-top-ten --json > ' +
        path.join(outputDir, 'semgrep-report.json'),
        { stdio: 'pipe' }
      );
      console.log('‚úÖ An√°lisis Semgrep completado');
    } catch (error) {
      console.error('‚ö†Ô∏è Error al ejecutar Semgrep:', error.message);
    }
  }
  
  console.log('üèÅ Auditor√≠a de seguridad completada');
  console.log(`üìä Informes disponibles en: ${outputDir}`);
  
  // Generar informe HTML resumen
  generateSummaryReport(outputDir);
}

function generateSummaryReport(outputDir: string) {
  // Aqu√≠ ir√≠a l√≥gica para generar un informe HTML resumen
  // a partir de los distintos informes JSON
  console.log('üìù Generando informe resumen...');
}

// Ejecutar si se llama directamente
if (require.main === module) {
  runSecurityAudit();
}

export default runSecurityAudit;
```

---

## üîè Auditor√≠as Manuales

### 1. Lista de verificaci√≥n de seguridad (checklist)

```typescript
// lib/security/audit-checklist.ts
export enum RiskLevel {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical',
}

export interface SecurityCheckItem {
  id: string;
  category: string;
  description: string;
  riskLevel: RiskLevel;
  remediation: string;
  owasp?: string; // Referencia a OWASP Top 10
  automated: boolean;
}

export const securityChecklist: SecurityCheckItem[] = [
  // Autenticaci√≥n
  {
    id: 'AUTH-01',
    category: 'Autenticaci√≥n',
    description: 'Verificar que las contrase√±as se almacenan con algoritmos de hash seguros (bcrypt, Argon2)',
    riskLevel: RiskLevel.CRITICAL,
    remediation: 'Implementar bcrypt o Argon2 para el hashing de contrase√±as',
    owasp: 'A02:2021 - Fallas Criptogr√°ficas',
    automated: true,
  },
  {
    id: 'AUTH-02',
    category: 'Autenticaci√≥n',
    description: 'Comprobar implementaci√≥n de bloqueo de cuentas tras m√∫ltiples intentos fallidos',
    riskLevel: RiskLevel.HIGH,
    remediation: 'Implementar mecanismo de rate limiting y bloqueo temporal de cuentas',
    owasp: 'A07:2021 - Fallas de Autenticaci√≥n',
    automated: false,
  },
  {
    id: 'AUTH-03',
    category: 'Autenticaci√≥n',
    description: 'Verificar que se utiliza 2FA para roles privilegiados',
    riskLevel: RiskLevel.HIGH,
    remediation: 'Implementar autenticaci√≥n en dos factores para administradores',
    owasp: 'A07:2021 - Fallas de Autenticaci√≥n',
    automated: false,
  },
  
  // Autorizaci√≥n
  {
    id: 'AUTHZ-01',
    category: 'Autorizaci√≥n',
    description: 'Verificar que existe validaci√≥n de permisos en todos los endpoints API',
    riskLevel: RiskLevel.CRITICAL,
    remediation: 'Implementar middleware de autorizaci√≥n en todas las rutas protegidas',
    owasp: 'A01:2021 - P√©rdida de Control de Acceso',
    automated: true,
  },
  {
    id: 'AUTHZ-02',
    category: 'Autorizaci√≥n',
    description: 'Comprobar que no existen referencias directas a objetos (IDOR)',
    riskLevel: RiskLevel.HIGH,
    remediation: 'Utilizar referencias indirectas o validar pertenencia de recursos',
    owasp: 'A01:2021 - P√©rdida de Control de Acceso',
    automated: false,
  },
  
  // Protecci√≥n de datos
  {
    id: 'DATA-01',
    category: 'Protecci√≥n de Datos',
    description: 'Verificar que los datos sensibles est√°n cifrados en reposo',
    riskLevel: RiskLevel.HIGH,
    remediation: 'Implementar cifrado a nivel de base de datos o campo',
    owasp: 'A02:2021 - Fallas Criptogr√°ficas',
    automated: false,
  },
  {
    id: 'DATA-02',
    category: 'Protecci√≥n de Datos',
    description: 'Comprobar que se utilizan conexiones HTTPS para toda la aplicaci√≥n',
    riskLevel: RiskLevel.HIGH,
    remediation: 'Configurar redirecci√≥n HTTP a HTTPS y cabeceras HSTS',
    owasp: 'A02:2021 - Fallas Criptogr√°ficas',
    automated: true,
  },
  
  // Protecci√≥n contra inyecciones
  {
    id: 'INJ-01',
    category: 'Inyecciones',
    description: 'Verificar protecci√≥n contra SQL Injection',
    riskLevel: RiskLevel.CRITICAL,
    remediation: 'Utilizar ORM con par√°metros preparados o consultas parametrizadas',
    owasp: 'A03:2021 - Inyecci√≥n',
    automated: true,
  },
  {
    id: 'INJ-02',
    category: 'Inyecciones',
    description: 'Comprobar protecci√≥n contra Cross-Site Scripting (XSS)',
    riskLevel: RiskLevel.HIGH,
    remediation: 'Implementar sanitizaci√≥n de entrada y salida, usar CSP',
    owasp: 'A03:2021 - Inyecci√≥n',
    automated: true,
  },
  
  // Configuraci√≥n de seguridad
  {
    id: 'CONFIG-01',
    category: 'Configuraci√≥n',
    description: 'Verificar cabeceras de seguridad HTTP configuradas correctamente',
    riskLevel: RiskLevel.MEDIUM,
    remediation: 'Configurar cabeceras CSP, X-Content-Type-Options, X-Frame-Options, etc.',
    owasp: 'A05:2021 - Configuraci√≥n de Seguridad Incorrecta',
    automated: true,
  },
  {
    id: 'CONFIG-02',
    category: 'Configuraci√≥n',
    description: 'Comprobar que no existen secretos en el c√≥digo fuente',
    riskLevel: RiskLevel.CRITICAL,
    remediation: 'Utilizar variables de entorno y sistemas de gesti√≥n de secretos',
    owasp: 'A05:2021 - Configuraci√≥n de Seguridad Incorrecta',
    automated: true,
  },
  
  // Otros
  {
    id: 'LOG-01',
    category: 'Logging',
    description: 'Verificar que existen logs de seguridad para eventos cr√≠ticos',
    riskLevel: RiskLevel.MEDIUM,
    remediation: 'Implementar logging de eventos de autenticaci√≥n y autorizaci√≥n',
    owasp: 'A09:2021 - Fallas en el Registro y Monitoreo',
    automated: true,
  },
  {
    id: 'CLIENT-01',
    category: 'Seguridad Frontend',
    description: 'Comprobar protecci√≥n contra ataques CSRF',
    riskLevel: RiskLevel.HIGH,
    remediation: 'Implementar tokens CSRF en formularios',
    owasp: 'A01:2021 - P√©rdida de Control de Acceso',
    automated: true,
  },
];

export function generateAuditChecklistMd(): string {
  let markdown = '# Lista de Verificaci√≥n de Seguridad\n\n';
  
  // Agrupar por categor√≠a
  const categorized = securityChecklist.reduce((acc, item) => {
    if (!acc[item.category]) {
      acc[item.category] = [];
    }
    acc[item.category].push(item);
    return acc;
  }, {} as Record<string, SecurityCheckItem[]>);
  
  // Generar markdown por categor√≠a
  for (const [category, items] of Object.entries(categorized)) {
    markdown += `## ${category}\n\n`;
    markdown += '| ID | Descripci√≥n | Riesgo | OWASP | Automatizado |\n';
    markdown += '|---|------------|--------|-------|-------------|\n';
    
    for (const item of items) {
      const riskEmoji = 
        item.riskLevel === RiskLevel.CRITICAL ? 'üî¥' :
        item.riskLevel === RiskLevel.HIGH ? 'üü†' :
        item.riskLevel === RiskLevel.MEDIUM ? 'üü°' : 'üü¢';
      
      markdown += `| ${item.id} | ${item.description} | ${riskEmoji} ${item.riskLevel} | ${item.owasp || 'N/A'} | ${item.automated ? '‚úÖ' : '‚ùå'} |\n`;
    }
    
    markdown += '\n';
  }
  
  return markdown;
}
```

### 2. Plantilla de informe de auditor√≠a

```typescript
// templates/security-audit-report.ts
import { securityChecklist, SecurityCheckItem, RiskLevel } from '../lib/security/audit-checklist';

export interface AuditFinding {
  checkItemId: string;
  status: 'pass' | 'fail' | 'na';
  notes: string;
  evidenceUrls?: string[];
  remediationPlan?: string;
}

export interface AuditReport {
  projectName: string;
  version: string;
  auditDate: string;
  auditors: string[];
  scope: string;
  methodology: string;
  findings: AuditFinding[];
  summary: {
    totalChecks: number;
    passed: number;
    failed: number;
    notApplicable: number;
    criticalIssues: number;
    highIssues: number;
    mediumIssues: number;
    lowIssues: number;
  };
  recommendations: string[];
}

export function generateAuditReportTemplate(): AuditReport {
  return {
    projectName: '[Nombre del Proyecto]',
    version: '[Versi√≥n del Proyecto]',
    auditDate: new Date().toISOString().split('T')[0],
    auditors: ['[Nombre del Auditor]'],
    scope: 'La auditor√≠a incluye revisi√≥n de c√≥digo, an√°lisis de configuraci√≥n y pruebas manuales en los entornos de desarrollo y preproducci√≥n.',
    methodology: 'Se sigue la metodolog√≠a OWASP Testing Guide v4 y se utilizan herramientas automatizadas y pruebas manuales.',
    findings: securityChecklist.map(item => ({
      checkItemId: item.id,
      status: 'na', // Por defecto marcar como "no aplicable"
      notes: '',
      evidenceUrls: [],
      remediationPlan: '',
    })),
    summary: {
      totalChecks: securityChecklist.length,
      passed: 0,
      failed: 0,
      notApplicable: securityChecklist.length,
      criticalIssues: 0,
      highIssues: 0,
      mediumIssues: 0,
      lowIssues: 0,
    },
    recommendations: [
      'Priorizar la resoluci√≥n de vulnerabilidades cr√≠ticas y altas',
      'Implementar pruebas de seguridad automatizadas en el pipeline CI/CD',
      'Realizar auditor√≠as de seguridad peri√≥dicas',
    ],
  };
}

export function generateAuditReportMd(report: AuditReport): string {
  const findingDetails = report.findings
    .filter(f => f.status === 'fail')
    .map(finding => {
      const checkItem = securityChecklist.find(c => c.id === finding.checkItemId);
      if (!checkItem) return '';
      
      let md = `### ${checkItem.id}: ${checkItem.description}\n\n`;
      md += `**Riesgo:** ${checkItem.riskLevel}\n\n`;
      md += `**Categor√≠a:** ${checkItem.category}\n\n`;
      md += finding.notes ? `**Detalles:** ${finding.notes}\n\n` : '';
      md += `**Recomendaci√≥n:** ${checkItem.remediation}\n\n`;
      md += finding.remediationPlan ? `**Plan de Acci√≥n:** ${finding.remediationPlan}\n\n` : '';
      
      if (finding.evidenceUrls && finding.evidenceUrls.length > 0) {
        md += '**Evidencia:**\n\n';
        for (const url of finding.evidenceUrls) {
          md += `- [Evidencia](mdc:${url})\n`;
        }
        md += '\n';
      }
      
      return md;
    }).join('---\n\n');
  
  const riskSummary = 
    report.summary.criticalIssues > 0 ? 'CR√çTICO' :
    report.summary.highIssues > 0 ? 'ALTO' :
    report.summary.mediumIssues > 0 ? 'MEDIO' :
    report.summary.lowIssues > 0 ? 'BAJO' : 'NINGUNO';
  
  let markdown = `# Informe de Auditor√≠a de Seguridad: ${report.projectName}\n\n`;
  markdown += `**Fecha:** ${report.auditDate}\n\n`;
  markdown += `**Versi√≥n:** ${report.version}\n\n`;
  markdown += `**Auditores:** ${report.auditors.join(', ')}\n\n`;
  
  markdown += '## Resumen Ejecutivo\n\n';
  markdown += `El nivel de riesgo general detectado es: **${riskSummary}**\n\n`;
  markdown += `Se han evaluado un total de ${report.summary.totalChecks} controles de seguridad, con los siguientes resultados:\n\n`;
  markdown += `- ‚úÖ **${report.summary.passed}** controles cumplen los est√°ndares de seguridad\n`;
  markdown += `- ‚ùå **${report.summary.failed}** controles presentan vulnerabilidades\n`;
  markdown += `- ‚ûñ **${report.summary.notApplicable}** controles no son aplicables\n\n`;
  
  markdown += '### Distribuci√≥n de Vulnerabilidades\n\n';
  markdown += `- üî¥ **${report.summary.criticalIssues}** Cr√≠ticas\n`;
  markdown += `- üü† **${report.summary.highIssues}** Altas\n`;
  markdown += `- üü° **${report.summary.mediumIssues}** Medias\n`;
  markdown += `- üü¢ **${report.summary.lowIssues}** Bajas\n\n`;
  
  markdown += '## Alcance\n\n';
  markdown += `${report.scope}\n\n`;
  
  markdown += '## Metodolog√≠a\n\n';
  markdown += `${report.methodology}\n\n`;
  
  if (report.summary.failed > 0) {
    markdown += '## Vulnerabilidades Detectadas\n\n';
    markdown += findingDetails;
  } else {
    markdown += '## Vulnerabilidades Detectadas\n\n';
    markdown += 'No se han detectado vulnerabilidades.\n\n';
  }
  
  markdown += '## Recomendaciones\n\n';
  for (const rec of report.recommendations) {
    markdown += `- ${rec}\n`;
  }
  
  return markdown;
}
```

---

## üß™ Pruebas de Penetraci√≥n

### 1. Configuraci√≥n de OWASP ZAP

```typescript
// scripts/security/run-zap-scan.ts
import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

interface ZapScanOptions {
  target: string;
  outputDir?: string;
  apiKey?: string;
  scanType?: 'baseline' | 'full' | 'api';
  contextFile?: string;
  spiderDurationMinutes?: number;
}

async function runZapScan(options: ZapScanOptions) {
  const {
    target,
    outputDir = './security-reports/zap',
    apiKey = process.env.ZAP_API_KEY,
    scanType = 'baseline',
    contextFile,
    spiderDurationMinutes = 5,
  } = options;
  
  if (!target) {
    throw new Error('Se requiere una URL objetivo para el escaneo ZAP');
  }
  
  // Crear directorio de salida si no existe
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  
  const dateStr = new Date().toISOString().replace(/[:.]/g, '-');
  const reportFilename = `zap-scan-report-${dateStr}`;
  
  console.log(`üîç Iniciando escaneo ZAP ${scanType} contra ${target}...`);
  
  let command = '';
  
  switch (scanType) {
    case 'baseline':
      // Escaneo b√°sico sin spider
      command = `docker run --rm -v "${path.resolve(outputDir)}:/zap/wrk:rw" -t owasp/zap2docker-stable zap-baseline.py ` +
        `-t ${target} -g gen.conf -r ${reportFilename}.html -x ${reportFilename}.xml`;
      break;
      
    case 'full':
      // Escaneo completo con spider y escaneo activo
      command = `docker run --rm -v "${path.resolve(outputDir)}:/zap/wrk:rw" -t owasp/zap2docker-stable zap-full-scan.py ` +
        `-t ${target} -g gen.conf -r ${reportFilename}.html -x ${reportFilename}.xml ` +
        `-d -m ${spiderDurationMinutes}`;
      break;
      
    case 'api':
      // Escaneo de API
      command = `docker run --rm -v "${path.resolve(outputDir)}:/zap/wrk:rw" -t owasp/zap2docker-stable zap-api-scan.py ` +
        `-t ${target} -f openapi -g gen.conf -r ${reportFilename}.html -x ${reportFilename}.xml`;
      break;
  }
  
  if (contextFile && fs.existsSync(contextFile)) {
    command += ` -n "${contextFile}"`;
  }
  
  // A√±adir API key si est√° disponible
  if (apiKey) {
    command += ` --api-key "${apiKey}"`;
  }
  
  try {
    console.log(`Ejecutando ZAP scan con: ${command.replace(apiKey || '', '******')}`);
    execSync(command, { stdio: 'inherit' });
    
    console.log(`‚úÖ Escaneo ZAP completado. Informe disponible en: ${outputDir}/${reportFilename}.html`);
    
    // Generar resumen de vulnerabilidades encontradas
    if (fs.existsSync(`${outputDir}/${reportFilename}.xml`)) {
      const xmlContent = fs.readFileSync(`${outputDir}/${reportFilename}.xml`, 'utf8');
      const summary = generateZapSummary(xmlContent);
      fs.writeFileSync(`${outputDir}/${reportFilename}-summary.json`, JSON.stringify(summary, null, 2));
      console.log('üìä Resumen de vulnerabilidades generado');
    }
    
    return {
      success: true,
      reportPath: `${outputDir}/${reportFilename}.html`,
      summaryPath: `${outputDir}/${reportFilename}-summary.json`,
    };
  } catch (error) {
    console.error('‚ùå Error al ejecutar el escaneo ZAP:', error);
    return {
      success: false,
      error: error.message,
    };
  }
}

function generateZapSummary(xmlContent: string) {
  // Parsear XML y generar resumen (simplificado para el ejemplo)
  // En la implementaci√≥n real utilizar√≠amos una biblioteca XML
  const highMatches = (xmlContent.match(/riskcode="3"/g) || []).length;
  const mediumMatches = (xmlContent.match(/riskcode="2"/g) || []).length;
  const lowMatches = (xmlContent.match(/riskcode="1"/g) || []).length;
  const infoMatches = (xmlContent.match(/riskcode="0"/g) || []).length;
  
  return {
    timestamp: new Date().toISOString(),
    vulnerabilities: {
      high: highMatches,
      medium: mediumMatches,
      low: lowMatches,
      info: infoMatches,
    },
    total: highMatches + mediumMatches + lowMatches + infoMatches,
  };
}

// Ejecutar si se llama directamente
if (require.main === module) {
  const target = process.argv[2];
  if (!target) {
    console.error('‚ùå Debe proporcionar una URL objetivo como argumento');
    process.exit(1);
  }
  
  runZapScan({ target, scanType: 'baseline' });
}

export default runZapScan;
```

### 2. Gesti√≥n de pruebas de seguridad

```typescript
// lib/security/pentest-management.ts
export enum PentestStatus {
  PLANNED = 'planned',
  IN_PROGRESS = 'in_progress',
  COMPLETED = 'completed',
  REMEDIATION = 'remediation',
  VERIFIED = 'verified',
}

export enum FindingSeverity {
  CRITICAL = 'critical',
  HIGH = 'high',
  MEDIUM = 'medium',
  LOW = 'low',
  INFO = 'info',
}

export enum FindingStatus {
  OPEN = 'open',
  IN_PROGRESS = 'in_progress',
  FIXED = 'fixed',
  VERIFIED = 'verified',
  NOT_APPLICABLE = 'not_applicable',
  ACCEPTED_RISK = 'accepted_risk',
}

export interface PentestFinding {
  id: string;
  title: string;
  description: string;
  severity: FindingSeverity;
  status: FindingStatus;
  cwe?: string; // Common Weakness Enumeration
  owasp?: string; // OWASP Top 10 Reference
  steps_to_reproduce: string[];
  evidence?: string;
  impact: string;
  remediation: string;
  assigned_to?: string;
  reported_date: string;
  updated_date: string;
  fixed_date?: string;
  verified_date?: string;
  risk_acceptance_reason?: string;
}

export interface PentestReport {
  id: string;
  name: string;
  status: PentestStatus;
  start_date: string;
  end_date?: string;
  scope: {
    description: string;
    targets: string[];
    excluded: string[];
    authentication_tested: boolean;
  };
  methodology: string[];
  findings: PentestFinding[];
  executive_summary: string;
  recommendations: string[];
  team_members: string[];
  tools_used: string[];
}

// Funci√≥n para generar un informe de pentest vac√≠o (plantilla)
export function createPentestTemplate(name: string): PentestReport {
  return {
    id: `PT-${Date.now()}`,
    name,
    status: PentestStatus.PLANNED,
    start_date: new Date().toISOString().split('T')[0],
    scope: {
      description: '',
      targets: [],
      excluded: [],
      authentication_tested: false,
    },
    methodology: [
      'Reconocimiento y recopilaci√≥n de informaci√≥n',
      'Identificaci√≥n de vectores de ataque',
      'Pruebas de autenticaci√≥n y autorizaci√≥n',
      'Pruebas de inyecci√≥n',
      'Pruebas de gesti√≥n de sesiones',
      'Validaci√≥n de entradas',
      'Pruebas de l√≥gica de negocio',
      'Pruebas de configuraci√≥n y despliegue',
    ],
    findings: [],
    executive_summary: '',
    recommendations: [],
    team_members: [],
    tools_used: [
      'OWASP ZAP',
      'Burp Suite',
      'Nmap',
      'Nikto',
    ],
  };
}

// Funci√≥n para a√±adir un hallazgo al informe
export function addFinding(
  report: PentestReport,
  finding: Omit<PentestFinding, 'id' | 'reported_date' | 'updated_date' | 'status'>
): PentestReport {
  const now = new Date().toISOString();
  const findingId = `F-${report.findings.length + 1}`;
  
  const newFinding: PentestFinding = {
    id: findingId,
    ...finding,
    status: FindingStatus.OPEN,
    reported_date: now,
    updated_date: now,
  };
  
  return {
    ...report,
    findings: [...report.findings, newFinding],
  };
}

// Funci√≥n para actualizar el estado de un hallazgo
export function updateFindingStatus(
  report: PentestReport,
  findingId: string,
  status: FindingStatus,
  notes?: string
): PentestReport {
  const now = new Date().toISOString();
  
  const updatedFindings = report.findings.map(finding => {
    if (finding.id !== findingId) return finding;
    
    const updatedFinding: PentestFinding = {
      ...finding,
      status,
      updated_date: now,
    };
    
    // A√±adir fechas espec√≠ficas seg√∫n el estado
    if (status === FindingStatus.FIXED) {
      updatedFinding.fixed_date = now;
    } else if (status === FindingStatus.VERIFIED) {
      updatedFinding.verified_date = now;
    } else if (status === FindingStatus.ACCEPTED_RISK && notes) {
      updatedFinding.risk_acceptance_reason = notes;
    }
    
    return updatedFinding;
  });
  
  return {
    ...report,
    findings: updatedFindings,
  };
}

// Generar resumen estad√≠stico del informe
export function generatePentestSummary(report: PentestReport) {
  const findingsBySeverity = report.findings.reduce(
    (acc, finding) => {
      acc[finding.severity] = (acc[finding.severity] || 0) + 1;
      return acc;
    },
    {} as Record<FindingSeverity, number>
  );
  
  const findingsByStatus = report.findings.reduce(
    (acc, finding) => {
      acc[finding.status] = (acc[finding.status] || 0) + 1;
      return acc;
    },
    {} as Record<FindingStatus, number>
  );
  
  return {
    totalFindings: report.findings.length,
    bySeverity: findingsBySeverity,
    byStatus: findingsByStatus,
    remediationProgress: findingsByStatus[FindingStatus.FIXED] 
      ? (findingsByStatus[FindingStatus.FIXED] / report.findings.length) * 100
      : 0,
    verificationProgress: findingsByStatus[FindingStatus.VERIFIED]
      ? (findingsByStatus[FindingStatus.VERIFIED] / report.findings.length) * 100
      : 0,
  };
}
```

---

## üìä M√©tricas de Seguridad

### 1. Dashboard de seguridad

```typescript
// lib/security/metrics.ts
import { PentestReport, FindingSeverity, FindingStatus } from './pentest-management';

export interface SecurityMetric {
  name: string;
  value: number;
  previous?: number;
  target?: number;
  trend?: 'up' | 'down' | 'stable';
  isGood?: boolean; // Si un aumento es bueno o malo
}

export interface SecurityMetrics {
  timestamp: string;
  overall_score: number; // 0-100
  vulnerability_metrics: {
    open_vulnerabilities: SecurityMetric;
    mean_time_to_fix: SecurityMetric; // D√≠as
    fix_rate: SecurityMetric; // Porcentaje
    severe_vulnerabilities: SecurityMetric;
    vulnerability_density: SecurityMetric; // Vulnerabilidades / 1000 l√≠neas de c√≥digo
  };
  testing_metrics: {
    security_tests_coverage: SecurityMetric; // Porcentaje
    automated_tests: SecurityMetric;
    penetration_test_coverage: SecurityMetric;
  };
  compliance_metrics: {
    critical_compliance_issues: SecurityMetric;
    compliance_pass_rate: SecurityMetric;
  };
  code_metrics: {
    secure_coding_violations: SecurityMetric;
    secrets_detected: SecurityMetric;
  };
}

// Funci√≥n para calcular el tiempo medio de resoluci√≥n (MTTR)
export function calculateMeanTimeToResolve(reports: PentestReport[]): number {
  let totalTimeToResolve = 0;
  let totalResolvedFindings = 0;
  
  for (const report of reports) {
    for (const finding of report.findings) {
      if (finding.status === FindingStatus.FIXED && finding.fixed_date) {
        const reportedDate = new Date(finding.reported_date);
        const fixedDate = new Date(finding.fixed_date);
        const timeToResolve = (fixedDate.getTime() - reportedDate.getTime()) / (1000 * 60 * 60 * 24); // D√≠as
        
        totalTimeToResolve += timeToResolve;
        totalResolvedFindings++;
      }
    }
  }
  
  return totalResolvedFindings > 0
    ? totalTimeToResolve / totalResolvedFindings
    : 0;
}

// Funci√≥n para contar vulnerabilidades abiertas por severidad
export function countOpenVulnerabilities(
  reports: PentestReport[],
  severities?: FindingSeverity[]
): number {
  return reports.flatMap(report => report.findings)
    .filter(finding => 
      finding.status === FindingStatus.OPEN &&
      (!severities || severities.includes(finding.severity))
    ).length;
}

// C√°lculo de tasa de resoluci√≥n
export function calculateFixRate(reports: PentestReport[]): number {
  const allFindings = reports.flatMap(report => report.findings);
  const fixedCount = allFindings.filter(f => 
    f.status === FindingStatus.FIXED || f.status === FindingStatus.VERIFIED
  ).length;
  
  return allFindings.length > 0
    ? (fixedCount / allFindings.length) * 100
    : 100; // Si no hay hallazgos, la tasa es 100%
}

// Puntuaci√≥n general de seguridad
export function calculateOverallSecurityScore(metrics: Omit<SecurityMetrics, 'timestamp' | 'overall_score'>): number {
  // C√°lculo simplificado de puntuaci√≥n en escala 0-100
  const weights = {
    vulnerability: 40,
    testing: 25,
    compliance: 20,
    code: 15,
  };
  
  // Vulnerabilidades (m√°s bajo es mejor)
  const vulnScore = 100 - Math.min(100, (
    metrics.vulnerability_metrics.open_vulnerabilities.value * 5 +
    metrics.vulnerability_metrics.severe_vulnerabilities.value * 10
  ) / 3);
  
  // Testing (m√°s alto es mejor)
  const testingScore = (
    metrics.testing_metrics.security_tests_coverage.value +
    metrics.testing_metrics.automated_tests.value / 10 +
    metrics.testing_metrics.penetration_test_coverage.value
  ) / 3;
  
  // Compliance (m√°s alto es mejor)
  const complianceScore = Math.max(0, 100 - (
    metrics.compliance_metrics.critical_compliance_issues.value * 10
  ));
  
  // C√≥digo (m√°s bajo es mejor)
  const codeScore = 100 - Math.min(100, (
    metrics.code_metrics.secure_coding_violations.value / 5 +
    metrics.code_metrics.secrets_detected.value * 20
  ));
  
  // Puntuaci√≥n ponderada
  return Math.round(
    (vulnScore * weights.vulnerability +
    testingScore * weights.testing +
    complianceScore * weights.compliance +
    codeScore * weights.code) / 100
  );
}

// Generar m√©tricas de ejemplo para demostraci√≥n
export function generateExampleMetrics(): SecurityMetrics {
  const metrics: Omit<SecurityMetrics, 'timestamp' | 'overall_score'> = {
    vulnerability_metrics: {
      open_vulnerabilities: {
        name: 'Vulnerabilidades abiertas',
        value: 12,
        previous: 15,
        trend: 'down',
        isGood: true,
      },
      mean_time_to_fix: {
        name: 'Tiempo medio para solucionar (d√≠as)',
        value: 5.3,
        previous: 7.1,
        target: 3,
        trend: 'down',
        isGood: true,
      },
      fix_rate: {
        name: 'Tasa de resoluci√≥n (%)',
        value: 78,
        previous: 65,
        target: 90,
        trend: 'up',
        isGood: true,
      },
      severe_vulnerabilities: {
        name: 'Vulnerabilidades graves',
        value: 3,
        previous: 5,
        target: 0,
        trend: 'down',
        isGood: true,
      },
      vulnerability_density: {
        name: 'Densidad de vulnerabilidades',
        value: 2.4,
        previous: 3.1,
        trend: 'down',
        isGood: true,
      },
    },
    testing_metrics: {
      security_tests_coverage: {
        name: 'Cobertura de pruebas de seguridad (%)',
        value: 65,
        previous: 58,
        target: 80,
        trend: 'up',
        isGood: true,
      },
      automated_tests: {
        name: 'Pruebas automatizadas',
        value: 123,
        previous: 98,
        trend: 'up',
        isGood: true,
      },
      penetration_test_coverage: {
        name: 'Cobertura de pentest (%)',
        value: 70,
        previous: 70,
        target: 90,
        trend: 'stable',
        isGood: false,
      },
    },
    compliance_metrics: {
      critical_compliance_issues: {
        name: 'Problemas cr√≠ticos de cumplimiento',
        value: 2,
        previous: 4,
        target: 0,
        trend: 'down',
        isGood: true,
      },
      compliance_pass_rate: {
        name: 'Tasa de cumplimiento (%)',
        value: 87,
        previous: 82,
        target: 100,
        trend: 'up',
        isGood: true,
      },
    },
    code_metrics: {
      secure_coding_violations: {
        name: 'Violaciones de c√≥digo seguro',
        value: 34,
        previous: 42,
        trend: 'down',
        isGood: true,
      },
      secrets_detected: {
        name: 'Secretos detectados',
        value: 0,
        previous: 3,
        trend: 'down',
        isGood: true,
      },
    },
  };
  
  return {
    timestamp: new Date().toISOString(),
    overall_score: calculateOverallSecurityScore(metrics),
    ...metrics,
  };
}
```

---

## üõ†Ô∏è Reglas para Cursor (Security Audit)

- Configurar escaneo autom√°tico de dependencias con cada build (npm audit, Snyk, etc.)
- Implementar an√°lisis est√°tico de c√≥digo (SonarQube, ESLint con reglas de seguridad)
- Ejecutar pruebas de penetraci√≥n automatizadas (OWASP ZAP) en entornos de QA/Staging
- Mantener una lista de verificaci√≥n de seguridad actualizada para revisiones manuales
- Realizar auditor√≠as de seguridad completas antes de cambios arquitecturales importantes
- Establecer proceso formal para seguimiento y resoluci√≥n de vulnerabilidades
- Ejecutar escaneo de secretos en c√≥digo (detect-secrets, trufflehog) antes de commits
- Establecer m√©tricas y KPIs de seguridad con seguimiento peri√≥dico
- Realizar an√°lisis de composici√≥n de software (SCA) para todas las dependencias
- Implementar verificaci√≥n de componentes de terceros antes de su incorporaci√≥n
- Mantener un inventario actualizado de activos (aplicaciones, APIs, bases de datos)
- Ejecutar auditor√≠as de permisos y accesos peri√≥dicamente
- Implementar proceso de revisi√≥n de seguridad en pull requests
- Establecer an√°lisis de configuraci√≥n de infraestructura como c√≥digo (IaC)
- Mantener documentaci√≥n actualizada de la arquitectura de seguridad
- Realizar simulacros de respuesta a incidentes de seguridad peri√≥dicamente
- Crear informes de seguridad ejecutivos para stakeholders
- Establecer programa de recompensas por bugs (bug bounty) o pruebas de seguridad externas
- Revisar y actualizar pol√≠ticas de seguridad al menos semestralmente
- Analizar patrones de ataque y establecer contramedidas proactivas 